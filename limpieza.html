<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.21">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Ismael Aguayo">

<title>Procesamiento y limpieza de texto con stringr, regex y la inteligencia artificial</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="limpieza_files/libs/clipboard/clipboard.min.js"></script>
<script src="limpieza_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="limpieza_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="limpieza_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="limpieza_files/libs/quarto-html/popper.min.js"></script>
<script src="limpieza_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="limpieza_files/libs/quarto-html/anchor.min.js"></script>
<link href="limpieza_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="limpieza_files/libs/quarto-html/quarto-syntax-highlighting-ea1d7ac60288e0f1efdbc993fd8432ae.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="limpieza_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="limpieza_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="limpieza_files/libs/bootstrap/bootstrap-4778e8f036b8341d3e254a5963141a88.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="quarto-light">

<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Procesamiento y limpieza de texto con stringr, regex y la inteligencia artificial</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Autor/a</div>
      <div class="quarto-title-meta-contents">
               <p>Ismael Aguayo <a href="https://orcid.org/0009-0002-4056-8242" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a></p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Fecha de publicación</div>
      <div class="quarto-title-meta-contents">
        <p class="date">28 de octubre de 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="1">
    <h2 id="toc-title">Contents</h2>
   
  <ul class="collapse">
  <li><a href="#configuración-de-la-sesión-e-introducción" id="toc-configuración-de-la-sesión-e-introducción" class="nav-link active" data-scroll-target="#configuración-de-la-sesión-e-introducción"><span class="header-section-number">1</span> Configuración de la sesión e introducción</a>
  <ul class="collapse">
  <li><a href="#carga-de-librerías" id="toc-carga-de-librerías" class="nav-link" data-scroll-target="#carga-de-librerías"><span class="header-section-number">1.1</span> Carga de librerías</a></li>
  <li><a href="#creamos-datos-simulados-de-texto-sucio-en-un-dataframe" id="toc-creamos-datos-simulados-de-texto-sucio-en-un-dataframe" class="nav-link" data-scroll-target="#creamos-datos-simulados-de-texto-sucio-en-un-dataframe"><span class="header-section-number">1.2</span> Creamos datos simulados de texto sucio en un dataframe</a></li>
  </ul></li>
  <li><a href="#introducción-a-las-funciones-de-stringr" id="toc-introducción-a-las-funciones-de-stringr" class="nav-link" data-scroll-target="#introducción-a-las-funciones-de-stringr"><span class="header-section-number">2</span> Introducción a las funciones de stringr</a>
  <ul class="collapse">
  <li><a href="#str_to_lower" id="toc-str_to_lower" class="nav-link" data-scroll-target="#str_to_lower"><span class="header-section-number">2.1</span> str_to_lower</a></li>
  <li><a href="#str_trim" id="toc-str_trim" class="nav-link" data-scroll-target="#str_trim"><span class="header-section-number">2.2</span> str_trim</a></li>
  <li><a href="#str_sub" id="toc-str_sub" class="nav-link" data-scroll-target="#str_sub"><span class="header-section-number">2.3</span> str_sub</a></li>
  <li><a href="#diagnosticando-str_length-y-str_detect" id="toc-diagnosticando-str_length-y-str_detect" class="nav-link" data-scroll-target="#diagnosticando-str_length-y-str_detect"><span class="header-section-number">2.4</span> Diagnosticando: str_length y str_detect</a></li>
  <li><a href="#reemplazando-la-suciedad-str_replace-o-str_remove" id="toc-reemplazando-la-suciedad-str_replace-o-str_remove" class="nav-link" data-scroll-target="#reemplazando-la-suciedad-str_replace-o-str_remove"><span class="header-section-number">2.5</span> Reemplazando la suciedad: str_replace (o str_remove)</a></li>
  <li><a href="#str_extract" id="toc-str_extract" class="nav-link" data-scroll-target="#str_extract"><span class="header-section-number">2.6</span> str_extract</a></li>
  <li><a href="#str_split" id="toc-str_split" class="nav-link" data-scroll-target="#str_split"><span class="header-section-number">2.7</span> str_split</a></li>
  </ul></li>
  <li><a href="#expresiones-regulares-para-casos-más-complejos" id="toc-expresiones-regulares-para-casos-más-complejos" class="nav-link" data-scroll-target="#expresiones-regulares-para-casos-más-complejos"><span class="header-section-number">3</span> Expresiones regulares para casos más complejos</a></li>
  <li><a href="#automatizando-la-limpieza-en-corpus-grandes-de-texto" id="toc-automatizando-la-limpieza-en-corpus-grandes-de-texto" class="nav-link" data-scroll-target="#automatizando-la-limpieza-en-corpus-grandes-de-texto"><span class="header-section-number">4</span> Automatizando la limpieza en corpus grandes de texto</a>
  <ul class="collapse">
  <li><a href="#función-de-limpieza" id="toc-función-de-limpieza" class="nav-link" data-scroll-target="#función-de-limpieza"><span class="header-section-number">4.1</span> Función de limpieza</a></li>
  <li><a href="#primer-enfoque-for-loop" id="toc-primer-enfoque-for-loop" class="nav-link" data-scroll-target="#primer-enfoque-for-loop"><span class="header-section-number">4.2</span> Primer enfoque: for loop</a></li>
  <li><a href="#segundo-enfoque-la-familia-apply" id="toc-segundo-enfoque-la-familia-apply" class="nav-link" data-scroll-target="#segundo-enfoque-la-familia-apply"><span class="header-section-number">4.3</span> Segundo enfoque: La familia <code>apply</code></a></li>
  <li><a href="#tercer-enfoque-método-directo" id="toc-tercer-enfoque-método-directo" class="nav-link" data-scroll-target="#tercer-enfoque-método-directo"><span class="header-section-number">4.4</span> Tercer enfoque: método directo</a></li>
  </ul></li>
  <li><a href="#uso-de-inteligencia-artificial-generativa-prácticas-generales" id="toc-uso-de-inteligencia-artificial-generativa-prácticas-generales" class="nav-link" data-scroll-target="#uso-de-inteligencia-artificial-generativa-prácticas-generales"><span class="header-section-number">5</span> Uso de Inteligencia Artificial Generativa: Prácticas generales</a>
  <ul class="collapse">
  <li><a href="#técnicas-de-prompteo-cómo-pedir-bien" id="toc-técnicas-de-prompteo-cómo-pedir-bien" class="nav-link" data-scroll-target="#técnicas-de-prompteo-cómo-pedir-bien"><span class="header-section-number">5.1</span> Técnicas de prompteo: cómo pedir bien</a></li>
  <li><a href="#prácticas-generales-para-usar-la-ia-como-co-piloto" id="toc-prácticas-generales-para-usar-la-ia-como-co-piloto" class="nav-link" data-scroll-target="#prácticas-generales-para-usar-la-ia-como-co-piloto"><span class="header-section-number">5.2</span> Prácticas generales para usar la IA como co-piloto</a></li>
  </ul></li>
  <li><a href="#cierre-y-ejercicios" id="toc-cierre-y-ejercicios" class="nav-link" data-scroll-target="#cierre-y-ejercicios"><span class="header-section-number">6</span> Cierre y ejercicios</a>
  <ul class="collapse">
  <li><a href="#html-anidado" id="toc-html-anidado" class="nav-link" data-scroll-target="#html-anidado"><span class="header-section-number">6.1</span> HTML anidado</a></li>
  <li><a href="#dataframe-de-tweets" id="toc-dataframe-de-tweets" class="nav-link" data-scroll-target="#dataframe-de-tweets"><span class="header-section-number">6.2</span> Dataframe de tweets</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="configuración-de-la-sesión-e-introducción" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Configuración de la sesión e introducción</h1>
<p>Hola a tod@s. Bienvenidos a este tutorial sobre procesamiento y limpieza de texto en R, realizado en el marco del curso de Métodos Computacionales para las Ciencias Sociales de la Universidad de Chile. Si están viendo esto fuera de la asignatura, espero que les sirva de igual manera.</p>
<p>En la unidad anterior, aprendieron a extraer datos, ya sea desde APIs o usando técnicas de web scraping. Lo más probable es que esos datos, tal como los tienen ahora, no estén listos para ser analizados. Seguramente tienen caracteres extraños, etiquetas HTML, saltos de línea, o simplemente un formato desordenado.</p>
<p>El objetivo de esta sesión es aprender los fundamentos para limpiar ese “texto sucio” y dejarlo preparado para un análisis de NLP.</p>
<p>Vamos a empezar configurando nuestra sesión de R.</p>
<section id="carga-de-librerías" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="carga-de-librerías"><span class="header-section-number">1.1</span> Carga de librerías</h2>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">#install_packages(pacman)</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(pacman)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>pacman<span class="sc">::</span><span class="fu">p_load</span>(stringr)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>La librería clave de hoy es stringr. stringr es parte del tidyverse y es nuestra herramienta clave para manipular texto. Nos da un conjunto de funciones muy consistentes y fáciles de entender para todas las operaciones comunes con strings/characters, y funciona de forma vectorial.</p>
</section>
<section id="creamos-datos-simulados-de-texto-sucio-en-un-dataframe" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="creamos-datos-simulados-de-texto-sucio-en-un-dataframe"><span class="header-section-number">1.2</span> Creamos datos simulados de texto sucio en un dataframe</h2>
<p>Para este tutorial, no vamos a cargar un set de datos gigante. Como cada uno de ustedes tiene datos distintos, con problemas de limpieza diferentes, lo más útil es crear nuestros propios datos simulados.</p>
<p>Vamos a crear un data.frame que contenga distintos tipos de “suciedad” que probablemente ustedes mismos están viendo en sus propios datos.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>df_sucios <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">id =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>,</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">texto =</span> <span class="fu">c</span>(</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"&lt;p&gt;Este es el primer texto. Con etiquetas de html.&lt;/p&gt;"</span>,</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"    HOLA MUNDO, este es el segundo texto. Con espacios extra.    "</span>,</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"&lt;div&gt;Aquí hay &lt;strong&gt;más&lt;/strong&gt; suciedad!</span><span class="sc">\n</span><span class="st">Y un salto de línea.&lt;/div&gt;"</span>,</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Un texto final @usuario con un link http://socialtec.cl y #hashtag"</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(df_sucios)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>  id                                                                    texto
1  1                   &lt;p&gt;Este es el primer texto. Con etiquetas de html.&lt;/p&gt;
2  2            HOLA MUNDO, este es el segundo texto. Con espacios extra.    
3  3 &lt;div&gt;Aquí hay &lt;strong&gt;más&lt;/strong&gt; suciedad!\nY un salto de línea.&lt;/div&gt;
4  4       Un texto final @usuario con un link http://socialtec.cl y #hashtag</code></pre>
</div>
</div>
<ul>
<li><p>En la fila 1, tenemos etiquetas HTML <code>&lt;p&gt;</code></p></li>
<li><p>En la fila 2, tenemos mayúsculas descontroladas y un montón de espacios en blanco inútiles al principio y al final.</p></li>
<li><p>En la fila 3, tenemos más HTML, incluso anidado (<code>&lt;strong&gt;</code>), y un salto de línea .</p></li>
<li><p>Y en la fila 4, tenemos ruido típico de redes sociales: una mención, un link (URL) y un hashtag.</p></li>
</ul>
</section>
</section>
<section id="introducción-a-las-funciones-de-stringr" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Introducción a las funciones de stringr</h1>
<p>Ahora que tenemos nuestros datos sucios en un dataframe, vamos a explorar las funciones clave de stringr para limpiarlos.</p>
<p>Iremos una por una, viendo qué hacen y cómo nos ayudan a resolver los problemas que identificamos. Para estos ejemplos, vamos a trabajar con los textos individuales de nuestro dataframe. Más adelante veremos cómo automatizar esto para todo el dataframe.</p>
<p>Empecemos por el Texto 2, que tenía dos problemas obvios: mayúsculas y espacios en blanco.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>texto_2 <span class="ot">&lt;-</span> df_sucios<span class="sc">$</span>texto[<span class="dv">2</span>]</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(texto_2)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "    HOLA MUNDO, este es el segundo texto. Con espacios extra.    "</code></pre>
</div>
</div>
<p>Para el análisis de texto, la máquina considera “hola” y “HOLA” como cosas distintas. Debemos normalizar este texto.</p>
<section id="str_to_lower" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="str_to_lower"><span class="header-section-number">2.1</span> str_to_lower</h2>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>texto_minusculas <span class="ot">&lt;-</span> <span class="fu">str_to_lower</span>(texto_2)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(texto_minusculas)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "    hola mundo, este es el segundo texto. con espacios extra.    "</code></pre>
</div>
</div>
<p>La función <code>str_to_lower</code> soluciona esto: ahora todo está en minúsculas. Sin embargo, seguimos teniendo espacios en blanco al inicio y al final. Esto puede obstaculizar nuestro conteo de palabras y análisis.</p>
</section>
<section id="str_trim" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="str_trim"><span class="header-section-number">2.2</span> str_trim</h2>
<p>Para eso, usamos str_trim, que “recorta” el espacio en blanco de ambos extremos.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>texto_limpio_2 <span class="ot">&lt;-</span> <span class="fu">str_trim</span>(texto_minusculas)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(texto_limpio_2)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "hola mundo, este es el segundo texto. con espacios extra."</code></pre>
</div>
</div>
<p>Ya tenemos un texto mucho más limpio. Podríamos hacer todo esto en un solo paso:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_trim</span>(<span class="fu">str_to_lower</span>(texto_2))</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "hola mundo, este es el segundo texto. con espacios extra."</code></pre>
</div>
</div>
</section>
<section id="str_sub" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="str_sub"><span class="header-section-number">2.3</span> str_sub</h2>
<p>A veces queremos extraer texto basándonos en su posición. Por ejemplo, los primeros 10 caracteres. Para eso usamos str_sub.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>texto_1 <span class="ot">&lt;-</span> df_sucios<span class="sc">$</span>texto[<span class="dv">1</span>]</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(texto_1)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "&lt;p&gt;Este es el primer texto. Con etiquetas de html.&lt;/p&gt;"</code></pre>
</div>
</div>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_sub</span>(texto_1, <span class="at">start =</span> <span class="dv">1</span>, <span class="at">end =</span> <span class="dv">10</span>)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "&lt;p&gt;Este es"</code></pre>
</div>
</div>
<p>Rara vez sabemos el lugar o índice exacto de la suciedad, pero igual es útil que sepan de la existencia de esta función.</p>
</section>
<section id="diagnosticando-str_length-y-str_detect" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="diagnosticando-str_length-y-str_detect"><span class="header-section-number">2.4</span> Diagnosticando: str_length y str_detect</h2>
<p>Antes de limpiar, generalmente necesitamos diagnosticar el corpus de texto que tenemos. En muchos casos es imposible hacer esto manualmente, ya que consta de muchas filas (miles o cientos de miles). Para esto utilizamos <code>str_length</code> y <code>str_detect</code>.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_length</span>(texto_1)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 54</code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_length</span>(texto_limpio_2)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 57</code></pre>
</div>
</div>
<p><code>str_length</code> nos indica el número de caracteres de un texto. Nos puede servir para filtrar textos vacíos.</p>
<p>Aquí nuestro mayor aliado es <code>str_detect</code>, que nos devuelve TRUE o FALSE si encuentra un patrón.</p>
<p>En el texto 4, ¿hay un link a una página web? Busquemos si contiene “http”.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>texto_4 <span class="ot">&lt;-</span> df_sucios<span class="sc">$</span>texto[<span class="dv">4</span>]</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(texto_4)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Un texto final @usuario con un link http://socialtec.cl y #hashtag"</code></pre>
</div>
</div>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_detect</span>(texto_4, <span class="at">pattern =</span> <span class="st">"http"</span>)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
</div>
<p>Esta función es muy útil para hacer filtros y categorías. Podríamos por ejemplo crear una nueva columna que nos indique qué textos contienen un hashtag.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_detect</span>(texto_4, <span class="at">pattern =</span> <span class="st">"#"</span>)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
</div>
</section>
<section id="reemplazando-la-suciedad-str_replace-o-str_remove" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="reemplazando-la-suciedad-str_replace-o-str_remove"><span class="header-section-number">2.5</span> Reemplazando la suciedad: str_replace (o str_remove)</h2>
<p>Podemos reemplazar un determinado patrón con la función <code>str_replace</code>. Si reemplazamos por nada, estaríamos simulando el comportamiento de la función <code>str_remove</code>.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(texto_1)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "&lt;p&gt;Este es el primer texto. Con etiquetas de html.&lt;/p&gt;"</code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>texto_sin_p <span class="ot">&lt;-</span> <span class="fu">str_replace</span>(texto_1, <span class="at">pattern =</span> <span class="st">"&lt;p&gt;"</span>, <span class="at">replacement =</span> <span class="st">""</span>) </span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(texto_sin_p)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Este es el primer texto. Con etiquetas de html.&lt;/p&gt;"</code></pre>
</div>
</div>
<p>Tendríamos que hacer dos pasos, uno para cada etiqueta HTML.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>texto_sin_p <span class="ot">&lt;-</span> <span class="fu">str_replace</span>(texto_sin_p, <span class="at">pattern =</span> <span class="st">"&lt;/p&gt;"</span>, <span class="at">replacement =</span> <span class="st">""</span>) </span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(texto_sin_p)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Este es el primer texto. Con etiquetas de html."</code></pre>
</div>
</div>
<p>Si quisiéramos eliminar todas las coincidencias de un patrón usamos <code>str_replace_all</code>, pero en este caso tendríamos el mismo problema. Esto ya que busca un patrón exacto. Si queremos eliminar todas las etiquetas HTML vamos a necesitar usar expresiones regulares.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(texto_1)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "&lt;p&gt;Este es el primer texto. Con etiquetas de html.&lt;/p&gt;"</code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>texto_sin_p <span class="ot">&lt;-</span> <span class="fu">str_replace_all</span>(texto_1, <span class="at">pattern =</span> <span class="st">"&lt;p&gt;"</span>, <span class="at">replacement =</span> <span class="st">""</span>) </span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(texto_sin_p)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Este es el primer texto. Con etiquetas de html.&lt;/p&gt;"</code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>texto_sin_letra_e <span class="ot">&lt;-</span> <span class="fu">str_replace_all</span>(texto_1, <span class="at">pattern =</span> <span class="st">"e"</span>, <span class="at">replacement =</span> <span class="st">""</span>) </span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(texto_sin_letra_e)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "&lt;p&gt;Est s l primr txto. Con tiqutas d html.&lt;/p&gt;"</code></pre>
</div>
</div>
<p>Para eliminar todas las letras “e” sí funciona.</p>
</section>
<section id="str_extract" class="level2" data-number="2.6">
<h2 data-number="2.6" class="anchored" data-anchor-id="str_extract"><span class="header-section-number">2.6</span> str_extract</h2>
<p>Si quisiéramos extraer solo una parte del corpus, por ejemplo el hashtag, nos sirve esta función. Aquí viene un adelanto de expresiones regulares. Le estamos pidiendo un # seguido de una cantidad de letras o números.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(texto_4)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Un texto final @usuario con un link http://socialtec.cl y #hashtag"</code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_extract</span>(texto_4, <span class="at">pattern =</span> <span class="st">"#[A-Za-z0-9]+"</span>)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "#hashtag"</code></pre>
</div>
</div>
<p>Solo extraerá la primera coincidencia, si queremos todas se utiliza <code>str_extract_all</code>.</p>
</section>
<section id="str_split" class="level2" data-number="2.7">
<h2 data-number="2.7" class="anchored" data-anchor-id="str_split"><span class="header-section-number">2.7</span> str_split</h2>
<p>Str_split nos permite “romper” un texto en pedazos, usando un separador que elijamos. Esto es la base de la tokenización (separar un texto en palabras), algo que verán más en los próximos contenidos del curso.</p>
<p>Usemos el texto 2 limpio que ya procesamos y separémoslo por los espacios.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb42"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(texto_limpio_2)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "hola mundo, este es el segundo texto. con espacios extra."</code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb44"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>lista <span class="ot">&lt;-</span> <span class="fu">str_split</span>(texto_limpio_2, <span class="at">pattern =</span> <span class="st">" "</span>, <span class="at">simplify=</span> F)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>matriz <span class="ot">&lt;-</span> <span class="fu">str_split</span>(texto_limpio_2, <span class="at">pattern =</span> <span class="st">" "</span>, <span class="at">simplify=</span> T)</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>vector <span class="ot">&lt;-</span> <span class="fu">unlist</span>(lista)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Como ven, tenemos diferentes opciones de outputs.</p>
</section>
</section>
<section id="expresiones-regulares-para-casos-más-complejos" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Expresiones regulares para casos más complejos</h1>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb45"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>texto_1 <span class="ot">&lt;-</span> df_sucios<span class="sc">$</span>texto[<span class="dv">1</span>]</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>texto_3 <span class="ot">&lt;-</span> df_sucios<span class="sc">$</span>texto[<span class="dv">3</span>]</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(texto_1)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "&lt;p&gt;Este es el primer texto. Con etiquetas de html.&lt;/p&gt;"</code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb47"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(texto_3)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "&lt;div&gt;Aquí hay &lt;strong&gt;más&lt;/strong&gt; suciedad!\nY un salto de línea.&lt;/div&gt;"</code></pre>
</div>
</div>
<p>Ya sabemos que <code>str_replace_all(texto_1, pattern = "&lt;p&gt;", replacement = "")</code> no es suficiente, ya que tenemos <code>&lt;/p&gt;</code>, y en el texto 3 tenemos divs, strongs y incluso un salto de línea. No podemos escribir código distinto para cada caso específico que encontremos en nuestros corpus.</p>
<p>Lo que necesitamos es una forma de decirle a R: “No busques el texto literal <code>&lt;p&gt;</code>. Busca un patrón que se vea como una etiqueta HTML”.</p>
<p>Para esto utilizamos las expresiones regulares.</p>
<p>Aquí hay un índice de algunos metacaracteres y qué significan:</p>
<p><img src="Regex-Cheat-Sheet-3362983929.png" class="img-fluid"></p>
<p>Lo importante no es que se los memoricen, sino que entiendan su funcionamiento general. El poder de regex nos permite en el parámetro ‘pattern’ especificar un rango de opciones mucho mayor que les ayudará a limpiar sus textos de forma mucho más eficaz.</p>
<ul>
<li>. significa cualquier carácter</li>
<li><ul>
<li>significa uno o más del carácter anterior</li>
</ul></li>
</ul>
<p>Intentemos eliminar todo lo que esté entre un ‘&lt;’ y otro ‘&gt;’.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb49"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_remove_all</span>(texto_1, <span class="at">pattern =</span> <span class="st">"&lt;.+&gt;"</span>)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] ""</code></pre>
</div>
</div>
<p>Elimina todo. ¿Por qué pasa esto? El cuantificador + es “codicioso”, intentará borrar todo lo posible, encuentra el primer &lt;, empieza a eliminar, y no se detuvo hasta encontrar el último &gt;.</p>
<p>Una forma de solucionarlo es utilizando el cuantificador perezoso, le decimos que se detenga en la primera coincidencia posible.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb51"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str_remove_all</span>(texto_1, <span class="at">pattern =</span> <span class="st">"&lt;.+?&gt;"</span>)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Este es el primer texto. Con etiquetas de html."</code></pre>
</div>
</div>
<p>Esto funciona, pero hay una forma más robusta de resolverlo. Podemos pedirle específicamente que no elimine ningún “&gt;”.</p>
<p>Para “cualquier carácter que NO sea…”, usamos la clase negada: [^…]. Esto es más seguro y preferible. Probamos con el texto 3 y vemos que funciona, eliminando todas las etiquetas HTML.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb53"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>texto_1_limpio <span class="ot">&lt;-</span> <span class="fu">str_remove_all</span>(texto_1, <span class="at">pattern =</span> <span class="st">"&lt;[^&gt;]+&gt;"</span>)</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>texto_1_limpio</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Este es el primer texto. Con etiquetas de html."</code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb55"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(texto_3)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "&lt;div&gt;Aquí hay &lt;strong&gt;más&lt;/strong&gt; suciedad!\nY un salto de línea.&lt;/div&gt;"</code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb57"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>texto_3_casi_limpio <span class="ot">&lt;-</span> <span class="fu">str_remove_all</span>(texto_3, <span class="at">pattern =</span> <span class="st">"&lt;[^&gt;]+&gt;"</span>)</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(texto_3_casi_limpio)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Aquí hay más suciedad!\nY un salto de línea."</code></pre>
</div>
</div>
<p>Como ven, el texto 3 ya está casi listo para analizarlo, pero queda un salto de línea. Podemos reemplazarlo con replace_all (o remove_all) por un espacio o por nada. Miren sus datos para saber esto, normalmente los saltos de línea () deberán cambiarlos por un espacio.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb59"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>texto_3_limpio <span class="ot">&lt;-</span> <span class="fu">str_replace_all</span>(texto_3_casi_limpio, <span class="at">pattern=</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span>, <span class="st">" "</span>)</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(texto_3_limpio)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Aquí hay más suciedad! Y un salto de línea."</code></pre>
</div>
</div>
</section>
<section id="automatizando-la-limpieza-en-corpus-grandes-de-texto" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Automatizando la limpieza en corpus grandes de texto</h1>
<p>Ya vimos cómo limpiar un texto con stringr y regex, en diferentes situaciones, pero ¿Cómo lo hacemos en un dataframe completo? Tenemos varios enfoques.</p>
<p>Primero, simularemos un dataframe de 100 filas con datos sucios.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb61"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>) <span class="co"># Para que los resultados sean reproducibles</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>titulos <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"&lt;p&gt;GRAN NOTICIA&lt;/p&gt;"</span>, <span class="st">"&lt;div&gt;impacto&lt;/div&gt;"</span>, <span class="st">"&lt;strong&gt;ÚLTIMO MINUTO&lt;/strong&gt;"</span>)</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>contenidos <span class="ot">&lt;-</span> <span class="fu">c</span>(</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">"Un texto de ejemplo con &lt;b&gt;mucha&lt;/b&gt; suciedad html."</span>,</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>  <span class="st">"OTRO TEXTO que necesita limpieza urgente."</span>,</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>  <span class="st">"    muchos espacios al inicio y final    "</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>df_grande <span class="ot">&lt;-</span> <span class="fu">data.frame</span>( <span class="at">id_noticia =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">100</span>, <span class="at">titulo =</span> <span class="fu">sample</span>(titulos, <span class="dv">100</span>, <span class="at">replace =</span> <span class="cn">TRUE</span>), <span class="at">contenido =</span> <span class="fu">sample</span>(contenidos, <span class="dv">100</span>, <span class="at">replace =</span> <span class="cn">TRUE</span>) )</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">head</span>(df_grande))</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>  id_noticia                         titulo
1          1 &lt;strong&gt;ÚLTIMO MINUTO&lt;/strong&gt;
2          2 &lt;strong&gt;ÚLTIMO MINUTO&lt;/strong&gt;
3          3 &lt;strong&gt;ÚLTIMO MINUTO&lt;/strong&gt;
4          4             &lt;div&gt;impacto&lt;/div&gt;
5          5 &lt;strong&gt;ÚLTIMO MINUTO&lt;/strong&gt;
6          6             &lt;div&gt;impacto&lt;/div&gt;
                                            contenido
1               muchos espacios al inicio y final    
2           OTRO TEXTO que necesita limpieza urgente.
3           OTRO TEXTO que necesita limpieza urgente.
4               muchos espacios al inicio y final    
5 Un texto de ejemplo con &lt;b&gt;mucha&lt;/b&gt; suciedad html.
6 Un texto de ejemplo con &lt;b&gt;mucha&lt;/b&gt; suciedad html.</code></pre>
</div>
</div>
<p>Tenemos HTML, mayúsculas y espacios por todos lados. Necesitamos aplicar una limpieza en varios pasos:</p>
<ol type="1">
<li>Remover todo el HTML (<code>&lt;[^&gt;]+&gt;</code>)</li>
<li>Convertir todo a minúsculas (<code>str_to_lower</code>)</li>
<li>Quitar espacios al inicio y final (<code>str_trim</code>)</li>
</ol>
<section id="función-de-limpieza" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="función-de-limpieza"><span class="header-section-number">4.1</span> Función de limpieza</h2>
<p>Primero, creamos una función que aplique estos tres pasos de forma unificada. Esto hace el código legible, reutilizable y fácil de mejorar.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb63"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>limpiar_mi_texto <span class="ot">&lt;-</span> <span class="cf">function</span>(texto_sucio) {</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Paso 1: Remover HTML</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>  texto_limpio <span class="ot">&lt;-</span> <span class="fu">str_remove_all</span>(texto_sucio, <span class="at">pattern =</span> <span class="st">"&lt;[^&gt;]+&gt;"</span>)</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Paso 2: Convertir a minúsculas</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>  texto_limpio <span class="ot">&lt;-</span> <span class="fu">str_to_lower</span>(texto_limpio)</span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Paso 3: Quitar espacios extra</span></span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>  texto_limpio <span class="ot">&lt;-</span> <span class="fu">str_trim</span>(texto_limpio)</span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Devolvemos el texto limpio</span></span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(texto_limpio)</span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Probamos la función:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb64"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(df_grande<span class="sc">$</span>contenido[<span class="dv">1</span>])</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "    muchos espacios al inicio y final    "</code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb66"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="fu">limpiar_mi_texto</span>(df_grande<span class="sc">$</span>contenido[<span class="dv">1</span>])</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "muchos espacios al inicio y final"</code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb68"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(df_grande<span class="sc">$</span>titulo[<span class="dv">1</span>])</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "&lt;strong&gt;ÚLTIMO MINUTO&lt;/strong&gt;"</code></pre>
</div>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb70"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="fu">limpiar_mi_texto</span>(df_grande<span class="sc">$</span>titulo[<span class="dv">1</span>])</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "último minuto"</code></pre>
</div>
</div>
<p>Funciona! Ahora solo hay que aplicarla a cada fila.</p>
</section>
<section id="primer-enfoque-for-loop" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="primer-enfoque-for-loop"><span class="header-section-number">4.2</span> Primer enfoque: for loop</h2>
<p>Esta es la práctica más transparente y legible. Iteramos por cada fila, aplicamos la función y guardamos el contenido en un vector de caracteres. Luego, asignamos ese vector a una nueva columna (contenido limpio for).</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb72"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>resultados_limpios_for <span class="ot">&lt;-</span> <span class="fu">c</span>()</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(df_grande)) {</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>  texto_a_limpiar <span class="ot">&lt;-</span> df_grande<span class="sc">$</span>contenido[i]</span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>  texto_ya_limpio <span class="ot">&lt;-</span> <span class="fu">limpiar_mi_texto</span>(texto_a_limpiar)</span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a>  resultados_limpios_for[i] <span class="ot">&lt;-</span> texto_ya_limpio </span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a>df_grande<span class="sc">$</span>contenido_limpio_for <span class="ot">&lt;-</span> resultados_limpios_for</span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">head</span>(df_grande<span class="sc">$</span>contenido_limpio_for))</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "muchos espacios al inicio y final"           
[2] "otro texto que necesita limpieza urgente."   
[3] "otro texto que necesita limpieza urgente."   
[4] "muchos espacios al inicio y final"           
[5] "un texto de ejemplo con mucha suciedad html."
[6] "un texto de ejemplo con mucha suciedad html."</code></pre>
</div>
</div>
</section>
<section id="segundo-enfoque-la-familia-apply" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="segundo-enfoque-la-familia-apply"><span class="header-section-number">4.3</span> Segundo enfoque: La familia <code>apply</code></h2>
<p>En sus entregas, muchos utilizaron este enfoque (con <code>sapply</code> o <code>lapply</code>). Es la forma más compacta de realizar esto, pero es esencial que comprendan lo que está ocurriendo por detrás.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb74"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>resultados_limpios_sapply <span class="ot">&lt;-</span> <span class="fu">sapply</span>(df_grande<span class="sc">$</span>contenido, limpiar_mi_texto)</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>df_grande<span class="sc">$</span>contenido_limpio_sapply <span class="ot">&lt;-</span> resultados_limpios_sapply</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">head</span>(df_grande<span class="sc">$</span>contenido_limpio_sapply))</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "muchos espacios al inicio y final"           
[2] "otro texto que necesita limpieza urgente."   
[3] "otro texto que necesita limpieza urgente."   
[4] "muchos espacios al inicio y final"           
[5] "un texto de ejemplo con mucha suciedad html."
[6] "un texto de ejemplo con mucha suciedad html."</code></pre>
</div>
</div>
<p>Como ven, ambos enfoques dan el mismo resultado. Sapply por detrás es un bucle for, que itera por cada elemento y devuelve un vector. Lo más importante es la función que ustedes construyen y le entregan a sapply, en este caso, <code>limpiar_mi_texto</code>.</p>
</section>
<section id="tercer-enfoque-método-directo" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="tercer-enfoque-método-directo"><span class="header-section-number">4.4</span> Tercer enfoque: método directo</h2>
<p><code>stringr</code>, al igual que muchos paquetes del tidyverse funciona de forma vectorial. Para casos más sencillos es posible que simplemente aplicando las funciones de stringr sobre la columna ya lleguen a solucionar su problema. Este enfoque es mucho más eficiente, asi que prefiéranlo si están trabajando con grandes volúmenes de datos. En vez de iterar de a una fila a la vez, se aplica la función sobre toda la columna (como un vector) de manera simultánea, utilizando un lenguaje mucho más eficiente por detrás (c++).</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb76"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>df_grande<span class="sc">$</span>contenido_limpio_vec <span class="ot">&lt;-</span> <span class="fu">limpiar_mi_texto</span>(df_grande<span class="sc">$</span>contenido)</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">head</span>(df_grande<span class="sc">$</span>contenido_limpio_vec))</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "muchos espacios al inicio y final"           
[2] "otro texto que necesita limpieza urgente."   
[3] "otro texto que necesita limpieza urgente."   
[4] "muchos espacios al inicio y final"           
[5] "un texto de ejemplo con mucha suciedad html."
[6] "un texto de ejemplo con mucha suciedad html."</code></pre>
</div>
</div>
<p>Todos estos enfoques nos sirven para títulos:</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb78"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>df_grande<span class="sc">$</span>titulo_limpio<span class="ot">&lt;-</span> <span class="fu">limpiar_mi_texto</span>(df_grande<span class="sc">$</span>titulo)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
</section>
<section id="uso-de-inteligencia-artificial-generativa-prácticas-generales" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Uso de Inteligencia Artificial Generativa: Prácticas generales</h1>
<p>Llegando al final de este taller, es crucial abordar el tema del uso de Inteligencia Artificial. Esta ha sido muy utilizada en sus entregas, e incluso es un objetivo pedagógico que aprendan a usarla. La IA es una herramienta muy poderosa para programar.</p>
<p>Sin embargo, para usarla de forma eficaz hay que seguir buenas prácticas, y no basta con copiar y pegar lo que les pasa el chatbot. De esta forma, se quedan en la “caja negra”, obtienen el resultado, pero no aprenden, y si su código falla en un futuro no sabrán cómo arreglarlo.</p>
<p>El objetivo de este módulo es prepararlos para usar la IA como un co-piloto, que les ayude a acelerar el trabajo pero también a aprender.</p>
<section id="técnicas-de-prompteo-cómo-pedir-bien" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="técnicas-de-prompteo-cómo-pedir-bien"><span class="header-section-number">5.1</span> Técnicas de prompteo: cómo pedir bien</h2>
<p>La respuesta de la IA depende totalmente de la calidad de su pregunta. Este es un marco que yo utilizo para sacar el mayor provecho de estas herramientas y que me entreguen código de mayor calidad posible, en cuatro pasos:</p>
<ol type="1">
<li><strong>Rol:</strong> “Toma el rol de un experto en Procesamiento de Lenguaje Natural y programador senior de R, especializado en el Tidyverse”.</li>
<li><strong>Tarea:</strong> “Necesito procesar un dataframe en R”.</li>
<li><strong>Contexto:</strong> (¡La parte más importante!) “Tengo un dataframe con n filas y estas columnas: id_noticia y contenido. La columna contenido tiene texto sucio. Un ejemplo de una celda de contenido es: ‘Un texto final <span class="citation" data-cites="usuario">@usuario</span> con un link http://socialtec.cl y #hashtag’”</li>
<li><strong>Reglas y formato:</strong> “Necesito una función de R que tome este texto y:</li>
</ol>
<ul>
<li><p>Elimine todas las URLs que empiecen con ‘http’.</p></li>
<li><p>Elimine todas las menciones (ej. ‘<span class="citation" data-cites="usuario">@usuario</span>’).</p></li>
<li><p>Extraiga (no elimine) los hashtags y los ponga en una nueva columna.</p></li>
<li><p>Por favor, explica cada paso de la función con comentarios en el código.</p></li>
<li><p>Prioriza usar bucles for en lugar de sapply para que yo pueda entender la lógica de la iteración.”</p></li>
</ul>
<p>De esta forma, no solo obtendrán un código que funciona, sino también entenderán por qué resulta, asegurándose una explicación detallada de cada paso lógico.</p>
</section>
<section id="prácticas-generales-para-usar-la-ia-como-co-piloto" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="prácticas-generales-para-usar-la-ia-como-co-piloto"><span class="header-section-number">5.2</span> Prácticas generales para usar la IA como co-piloto</h2>
<ol type="1">
<li>Pedirle que les expliquen lo que está haciendo, si no entienden cada uno de los pasos algo está mal. Díganle que les explique el código paso a paso y de forma sencilla.</li>
<li>Intentar que no comprima tanto el código. Las funciones de la familia apply son útlies para código de producción y para usuarios de R avanzados, pero disminuyen la legibilidad y no permiten ver la lógica detrás de las funciones que construyen. Necesitan código legible y comprensible, y una cadena de muchos <code>df$limpio &lt;- sapply(df$sucio, function(x) str_trim(str_to_lower(x)))</code> puede ser muy compleja.</li>
<li>Úsenla como depurador (Debugger): ¡Es de los mejores usos! intenten avanzar lo que más puedan por su cuenta, y utilicen la Inteligencia Artificial para diagnosticar y resolver los errores que encuentren en el código.</li>
<li>La IA inventa y alucina. Siempre revisen la documentación oficial de los paquetes como referencia, sobre todo para los procedimientos más sensibles (por ejemplo, si van a ejecutar algo en una base de datos y no tienen un backup, no peguen un código de la IA sin pensarlo).</li>
<li><strong>Muy importante:</strong> Si manejan datos sensibles tengan mucho cuidado con las políticas de la IA que están utilizando. No manden nunca datos privados que luego puedan utilizar para entrenar a sus modelos.</li>
</ol>
</section>
</section>
<section id="cierre-y-ejercicios" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Cierre y ejercicios</h1>
<p>Con esto llegamos al final de la cápsula. Hasta ahora:</p>
<ol type="1">
<li>Revisamos las funciones de <code>stringr</code> en casos de uso aplicados</li>
<li>Entendimos para qué necesitamos <code>regex</code> y lo utilizamos para limpiar etiquetas de HTML</li>
<li>Aprendimos a automatizar la limpieza de texto en dataframes, creando una función y aplicándola a través de tres enfoques: <code>for loop</code>, <code>sapply</code> y vectorización</li>
<li>Vimos como usar la IA como co-piloto en nuestro aprendizaje</li>
</ol>
<p>La idea es que este taller les sirva para limpiar texto independiente del contexto en el que lo necesiten realizar. El proceso de limpieza no es lineal, es iterativo. Probablemente intentarán una función, luego verán otro carácter indeseado, corregirán su función y seguirán iterando. Ante cualquier duda, no duden escribirme a mi <a href="mailto:ismaelaguayob@gmail.com">correo personal</a>.</p>
<p>Para practicar estos contenidos, les dejo los dos siguientes ejercicios:</p>
<section id="html-anidado" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="html-anidado"><span class="header-section-number">6.1</span> HTML anidado</h2>
<p>Este es un solo texto. El desafío es que tiene varias etiquetas HTML anidadas y un salto de línea.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb79"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>texto_ej_1 <span class="ot">&lt;-</span> <span class="st">"&lt;div&gt;&lt;p&gt;Un &lt;b&gt;artículo&lt;/b&gt; nuevo! </span><span class="sc">\n</span><span class="st"> (Leer más en...)&lt;/p&gt;&lt;/div&gt;"</span></span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>TAREA: Escribe el código para limpiar ‘texto_ej_1’. El resultado final debería ser un solo string: “Un artículo nuevo! (Leer más en…)”</p>
<p>Necesitarán al menos dos pasos: 1. Remover todo el HTML 2. Reemplazar el salto de línea</p>
</section>
<section id="dataframe-de-tweets" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="dataframe-de-tweets"><span class="header-section-number">6.2</span> Dataframe de tweets</h2>
<p>Aquí hay un data.frame de tweets</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb80"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Datos para el ejercicio 2</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>df_tweets <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">id_tweet =</span> <span class="fu">c</span>(<span class="dv">101</span>, <span class="dv">102</span>, <span class="dv">103</span>),</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">texto_tweet =</span> <span class="fu">c</span>(</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"¡Qué buen análisis de @autor_famoso! Revisa su paper en http://link.cl/paper1 #CienciaSocial"</span>,</span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"No estoy de acuerdo con el 2do punto... </span><span class="sc">\n\n</span><span class="st"> #debate 👎"</span>,</span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">"    terminé de leer el texto para mañana    "</span></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>TAREA: Crea una NUEVA función llamada limpiar_tweet(texto).</p>
<p>Tu función debe hacer (al menos) los siguientes pasos: a. Remover todas las URLs (Pista: un patrón simple es http\S+, que significa ‘http’ seguido de uno o más caracteres que no sean espacios). b. Remover todas las menciones (Pista: @ seguido de caracteres). c.&nbsp;Remover todos los hashtags. d.&nbsp;Reemplazar los saltos de línea por un espacio ” “. e. Poner todo en minúsculas. f.&nbsp;Quitar los espacios de los costados (str_trim).</p>
<p>Aplica tu nueva función limpiar_tweet al dataframe df_tweets (usando for, sapply o el método vectorial directo).</p>
<p>Guarda el resultado en una nueva columna llamada texto_limpio.</p>
<p>Bonus: Crea una nueva columna con los hashtags.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copiado");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copiado");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>